# 阅读记录
## 动态内存和类
### 问题产生原因
C++ 默认的复制构造函数造成了一个错误，默认的赋值运算符也造成了一个错误
### 解决方案：
1. 显示的定义一个复制构造函数；如果类中包含使用了new来初始化**指针**成员，则应当显示定义复制构造函数，以实现深复制而不是浅复制；
2. 与1类似，要提供赋值运算符的定义：例如a=b，需要先释放掉a中分配的内存，然后重新申请内存，再将b中内容复制到a（针对指针成员而言）

## C++11引入nullptr代表空指针，防止与数值0混淆

## 重载比较运算符和[]运算符，注意 [] 的重载先后顺序以及返回值是否为常量

## 静态类成员函数：static声明，且只能使用静态成员变量

## delete 可以用于空指针

## 默认的逐成员复制和赋值行为具有一定的智能

## 返回对象的说明{返回指向const对象的引用，返回指向非const对象的引用，返回对象，返回const对象}

