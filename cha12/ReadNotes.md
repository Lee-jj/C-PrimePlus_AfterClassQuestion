# cha12 类和动态内存分配
## 动态内存和类
### 问题产生原因
C++ 默认的复制构造函数造成了一个错误，默认的赋值运算符也造成了一个错误
### 解决方案：
1. 显示的定义一个复制构造函数；如果类中包含使用了new来初始化**指针**成员，则应当显示定义复制构造函数，以实现深复制而不是浅复制；
2. 与1类似，要提供赋值运算符的定义：例如a=b，需要先释放掉a中分配的内存，然后重新申请内存，再将b中内容复制到a（针对指针成员而言）
3. 总结：构造函数使用new的类应定义一个分配内存的复制构造函数和一个重载赋值运算符的类成员函数，最终的目的都是执行深复制而不是仅仅复制指向数据的指针

## C++11引入nullptr代表空指针，防止与数值0混淆

## 重载比较运算符和[]运算符，注意 [] 的重载先后顺序以及返回值是否为常量

## 静态类成员函数：static声明，且只能使用静态成员变量

## delete 可以用于空指针
1. 如果析构函数使用delete来释放内存，在类中的每个构造函数都应当使用new来初始化指针，或者将其设置为空指针
2. 如果使用 delete[] 来释放内存，则构造函数应当使用 new[]

## 默认的逐成员复制和赋值行为具有一定的智能

## 返回对象的说明{返回指向const对象的引用，返回指向非const对象的引用，返回对象，返回const对象}

## 指向对象的指针

## 定位new运算符的一些问题：
1. 定位new运算符能够在分配内存时指定内存位置
2. delete不能跟定位new运算符配合使用
3. 使用定位new运算符创建的对象需要显式的调用析构函数，这是需要显式调用析构函数的少数几种情况之一
4. 当所有使用定位new运算符创建的对象都销毁后，才能释放用于存储这些对象的缓冲区

## 成员初始化列表：用于构造函数，用于初始化类中的成员变量的值
1. 对于 非静态const类成员 和 被声明为引用的类成员，只能使用初始化列表，只能在创建时被初始化，C++11允许类内初始化用于非静态const类成员
2. 对于简单成员函数，使用初始化列表和在函数体中使用赋值没什么区别，但是使用成员初始化列表的效率更高
3. 使用类内初始化与使用成员初始化列表等价，但是成员初始化列表会覆盖类内初始化的值

